package wait.task1;

/*
* 1. Реализовать шаблон Producer Consumer. [#1098]
  Петр Арсентьев,  11.12.18 16:05
Реализуйте шаблон Producer Consumer.

Для этого вам необходимо реализовать собственную версию bounded blocking queue. Это блокирующая очередь, ограниченная по размеру. В данном шаблоне Producer помещает данные в очередь, а Consumer извлекает данные из очереди.

Если очередь заполнена полностью, то при попытке добавления поток Producer блокируется, до тех пор пока Consumer не извлечет очередные данные, т.е. в очереди появится свободное место. И наоборот если очередь пуста поток Consumer блокируется, до тех пор пока Producer не поместит в очередь данные.

В задании нельзя использовать потокобезопасные коллекции реализованные в JDK. Ваша задача используя, wait/notify реализовать блокирующую очередь.

Давайте сделаем каркас нашего приложения.

Producer Consumer - по сути это обычные нити.

Для того чтобы нить перевести в ждущее состояние необходимо в ее процессе вызвать метод wait() для объекта монитора.

Для того чтобы разбудить нить, нужно, чтобы другая нить вызвала у объекта монитора метод notify().

Теперь давайте перейдем к созданию нашей блокирующей очереди.

Создадим класс SimpleBlockingQueue

@ThreadSafe
public class SimpleBlockingQueue<T> {

    @GuardedBy("this")
    private Queue<T> queue = new LinkedList<>();

    public void offer(T value) {
    }

    public T poll() {
        return null;
    }
}
Каждой нити нужно передать объект:

new SimpleBlockingQueue<Integer>()

Этот объект будет общим ресурсом между этими нитями.

Метод poll() должен вернуть объект из внутренней коллекции. Если в коллекции объектов нет, то нужно перевести текущую нить в состояние ожидания.

Важный момент, когда нить переводить в состояние ожидания, то она отпускает объект монитор и другая нить тоже может выполнить этот метод.

Рассмотрим диаграмму выполнения этой программы:



То есть у нас может быть бесконечное число пользователей этой очереди.

Теперь давайте посмотрим диаграмму когда у нас есть производитель данных:



Задание.

1. Реализовать методы poll() и offer().

2. Написать тесты. В тестах должны быть две нити: одна производитель, другая потребитель.

Через методы join() добиться последовательного выполнение программы.
*
* */